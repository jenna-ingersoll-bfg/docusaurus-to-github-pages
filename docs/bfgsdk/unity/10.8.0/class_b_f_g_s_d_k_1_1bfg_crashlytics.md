# BFGSDK.bfgCrashlytics Class Reference

<div class="contents"><p>API for interfacing with BFG-managed Crashlytics.    <a href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#details">More...</a></p><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_f_g_s_d_k_1_1bfg_crashlytics_1_1_initialization_result.html">InitializationResult</a></td></tr><tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct indicating the result of a <a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html" title="API for interfacing with BFG-managed Crashlytics.">bfgCrashlytics</a> initialization attempt.  <a href="struct_b_f_g_s_d_k_1_1bfg_crashlytics_1_1_initialization_result.html#details">More...</a><br /></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a> Static Public Member Functions</h2></td></tr><tr class="memitem:a6013b0ba541302c309d096a6d92099d1"><td class="memItemLeft" align="right" valign="top">static async Task&lt; <a class="el" href="struct_b_f_g_s_d_k_1_1bfg_crashlytics_1_1_initialization_result.html">InitializationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#a6013b0ba541302c309d096a6d92099d1">InitializeAsync</a> ()</td></tr><tr class="memdesc:a6013b0ba541302c309d096a6d92099d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and configure Crashlytics. Must be called prior to any other <a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html" title="API for interfacing with BFG-managed Crashlytics.">bfgCrashlytics</a> methods.  <a href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#a6013b0ba541302c309d096a6d92099d1">More...</a><br /></td></tr><tr class="separator:a6013b0ba541302c309d096a6d92099d1"><td class="memSeparator" colspan="2">&#160;</td></tr><tr class="memitem:a08d66deea80d2970cc1fec56b0e4e3a4"><td class="memItemLeft" align="right" valign="top"><a id="a08d66deea80d2970cc1fec56b0e4e3a4" name="a08d66deea80d2970cc1fec56b0e4e3a4"></a> static void&#160;</td><td class="memItemRight" valign="bottom"><b>Shutdown</b> ()</td></tr><tr class="memdesc:a08d66deea80d2970cc1fec56b0e4e3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables Crashlytics and releases any managed handles/resources. <br /></td></tr><tr class="separator:a08d66deea80d2970cc1fec56b0e4e3a4"><td class="memSeparator" colspan="2">&#160;</td></tr><tr class="memitem:a3a072e21e6fce8ee080e2092f210364a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#a3a072e21e6fce8ee080e2092f210364a">Log</a> (string message)</td></tr><tr class="memdesc:a3a072e21e6fce8ee080e2092f210364a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds logging that is sent with your crash data. The logging is only visible in the Crashlytics dashboard.  <a href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#a3a072e21e6fce8ee080e2092f210364a">More...</a><br /></td></tr><tr class="separator:a3a072e21e6fce8ee080e2092f210364a"><td class="memSeparator" colspan="2">&#160;</td></tr><tr class="memitem:ae63bef754ac97b6f39089fbb37351440"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#ae63bef754ac97b6f39089fbb37351440">LogException</a> (Exception exception)</td></tr><tr class="memdesc:ae63bef754ac97b6f39089fbb37351440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a non-fatal event. The events are grouped and displayed similarly to crashes. Keep in mind that this method can be expensive. The total number of events that can be recorded during your app's life-cycle is limited by a fixed-size circular buffer. If the buffer is overrun, the oldest data is dropped. Errors are relayed to Crashlytics on a subsequent launch of your application.  <a href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#ae63bef754ac97b6f39089fbb37351440">More...</a><br /></td></tr><tr class="separator:ae63bef754ac97b6f39089fbb37351440"><td class="memSeparator" colspan="2">&#160;</td></tr><tr class="memitem:ad9d86732aacef0ce5802b1d38fa0f7ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#ad9d86732aacef0ce5802b1d38fa0f7ff">SetCustomKey</a> (string key, string value)</td></tr><tr class="memdesc:ad9d86732aacef0ce5802b1d38fa0f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a custom key and value to be associated with subsequent fatal and non-fatal reports. Multiple calls to this method with the same key will update the value for that key. The value of any key at the time of a fatal or non-fatal event will be associated with that event.  <a href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#ad9d86732aacef0ce5802b1d38fa0f7ff">More...</a><br /></td></tr><tr class="separator:ad9d86732aacef0ce5802b1d38fa0f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr></table><a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p >API for interfacing with BFG-managed Crashlytics. </p></div><h2 class="groupheader">Member Function Documentation</h2><a id="a6013b0ba541302c309d096a6d92099d1" name="a6013b0ba541302c309d096a6d92099d1"></a><h2 class="memtitle"><span class="permalink"><a href="#a6013b0ba541302c309d096a6d92099d1">&#9670;&nbsp;</a></span>InitializeAsync()</h2><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static async Task&lt; <a class="el" href="struct_b_f_g_s_d_k_1_1bfg_crashlytics_1_1_initialization_result.html">InitializationResult</a> &gt; BFGSDK.bfgCrashlytics.InitializeAsync </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Initialize and configure Crashlytics. Must be called prior to any other <a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html" title="API for interfacing with BFG-managed Crashlytics.">bfgCrashlytics</a> methods. </p><dl class="section return"><dt>Returns</dt><dd>Task used to track the asynchronous initialization operation.</dd></dl><p ><a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html#a6013b0ba541302c309d096a6d92099d1" title="Initialize and configure Crashlytics. Must be called prior to any other bfgCrashlytics methods.">bfgCrashlytics.InitializeAsync()</a>.ContinueWith(task =&gt; \{ if (task.Result.Succeeded) \{ // OK to use <a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html" title="API for interfacing with BFG-managed Crashlytics.">bfgCrashlytics</a> methods \} else \{ // Not OK to use <a class="el" href="class_b_f_g_s_d_k_1_1bfg_crashlytics.html" title="API for interfacing with BFG-managed Crashlytics.">bfgCrashlytics</a> methods Debug.LogError($"Failed to initialize crashlytics: \{task.Result\}"); \} \}); </p></div></div><a id="a3a072e21e6fce8ee080e2092f210364a" name="a3a072e21e6fce8ee080e2092f210364a"></a><h2 class="memtitle"><span class="permalink"><a href="#a3a072e21e6fce8ee080e2092f210364a">&#9670;&nbsp;</a></span>Log()</h2><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static void BFGSDK.bfgCrashlytics.Log </td><td>(</td><td class="paramtype">string&#160;</td><td class="paramname"><em>message</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Adds logging that is sent with your crash data. The logging is only visible in the Crashlytics dashboard. </p><dl class="params"><dt>Parameters</dt><dd><table class="params"><tr><td class="paramname">message</td><td>The message to log.</td></tr></table></dd></dl></div></div><a id="ae63bef754ac97b6f39089fbb37351440" name="ae63bef754ac97b6f39089fbb37351440"></a><h2 class="memtitle"><span class="permalink"><a href="#ae63bef754ac97b6f39089fbb37351440">&#9670;&nbsp;</a></span>LogException()</h2><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static void BFGSDK.bfgCrashlytics.LogException </td><td>(</td><td class="paramtype">Exception&#160;</td><td class="paramname"><em>exception</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Records a non-fatal event. The events are grouped and displayed similarly to crashes. Keep in mind that this method can be expensive. The total number of events that can be recorded during your app's life-cycle is limited by a fixed-size circular buffer. If the buffer is overrun, the oldest data is dropped. Errors are relayed to Crashlytics on a subsequent launch of your application. </p><dl class="params"><dt>Parameters</dt><dd><table class="params"><tr><td class="paramname">exception</td><td>A C# Exception object that will be transformed to a native error for iOS and Android.</td></tr></table></dd></dl></div></div><a id="ad9d86732aacef0ce5802b1d38fa0f7ff" name="ad9d86732aacef0ce5802b1d38fa0f7ff"></a><h2 class="memtitle"><span class="permalink"><a href="#ad9d86732aacef0ce5802b1d38fa0f7ff">&#9670;&nbsp;</a></span>SetCustomKey()</h2><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static void BFGSDK.bfgCrashlytics.SetCustomKey </td><td>(</td><td class="paramtype">string&#160;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">string&#160;</td><td class="paramname"><em>value</em>&#160;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Records a custom key and value to be associated with subsequent fatal and non-fatal reports. Multiple calls to this method with the same key will update the value for that key. The value of any key at the time of a fatal or non-fatal event will be associated with that event. </p><p >A maximum of 64 key/value pairs can be written, and new keys added beyond that limit will be ignored. Keys or values that exceed 1024 characters will be truncated. </p><dl class="params"><dt>Parameters</dt><dd><table class="params"><tr><td class="paramname">key</td><td>A unique key </td></tr><tr><td class="paramname">value</td><td>A value to be associated with the given key. This can be any of the following data types: String, int or Integer, boolean or Boolean, float or Float, double or Double, or long or Long. </td></tr></table></dd></dl></div></div></div> 
